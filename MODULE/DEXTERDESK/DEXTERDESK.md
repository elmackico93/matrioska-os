DexterDesk

An AI-powered, cross-platform desktop organizer and productivity assistant for Windows, macOS, Linux, Android, and iOS.

Project Overview

DexterDesk is a comprehensive solution to cluttered desktops and disorganized workflows. In many workplaces, employees waste significant time searching for files or juggling chaotic windows. Studies show nearly 30% of professionals have 100+ files on their desktop ￼, and over half of office workers report wasting time searching for files in cluttered systems ￼. DexterDesk’s purpose is to solve this problem by intelligently organizing your desktop, managing windows, and synchronizing your workspace across devices. It leverages smart automation and AI to keep your digital workspace tidy and efficient, so you can focus on what matters instead of housekeeping.

Key benefits: DexterDesk declutters your screen and file system automatically, reducing time spent on manual organization. It provides a consistent user experience across platforms, meaning your workflow feels the same whether you’re on Windows, Mac, Linux, or a mobile device ￼. By automating repetitive tasks and employing AI-driven rules, DexterDesk improves productivity and minimizes distractions. Whether you’re a developer, designer, or casual user, DexterDesk adapts to your needs—helping you maintain an organized desktop, streamline multitasking, and even experiment with new interfaces like augmented reality. The result is a cleaner workspace, improved focus, and a smarter desktop that works for you.

Installation and Setup

DexterDesk is available on all major operating systems. You can install it on your desktop (Windows, macOS, Linux) as well as mobile devices (Android and iOS). Follow the platform-specific instructions below to get started. Before installation, please ensure your system meets the minimum requirements for that platform.

Windows (Installer .exe)

System Requirements: Windows 10 or later (64-bit), at least 4 GB RAM, and ~200 MB of free disk space.
Installation Steps:
	1.	Download: Get the latest Windows .exe installer from the DexterDesk Releases or the official website. (If available on Microsoft Store, you can install it from there as well.)
	2.	Run Installer: Double-click the downloaded DexterDesk_Setup.exe. If SmartScreen prompts, choose “Run anyway” (the app is signed and safe).
	3.	Setup Wizard: Follow the installation wizard prompts. You can choose the installation directory and whether to create a Start Menu shortcut. The wizard will copy all necessary files.
	4.	Launch: After installation, launch DexterDesk from the Start Menu or desktop shortcut. On first launch, you may be asked to grant certain permissions (for example, to allow DexterDesk to start at login or to access certain folders).
	5.	Initial Configuration: DexterDesk will run in the system tray (notification area). Click its tray icon to open the interface. We recommend enabling “Start with Windows” during initial setup so that DexterDesk can organize your desktop automatically on boot.

macOS (Installer .pkg or .dmg)

System Requirements: macOS 10.15 (Catalina) or later, Apple Silicon (M1/M2) and Intel supported, ~200 MB free disk space.
Installation Steps:
	1.	Download: Download the latest macOS installer. If a .dmg is provided, open it to find the DexterDesk app. If a .pkg is provided, run it to launch the installer.
	2.	Install App: For a DMG, drag the DexterDesk app icon into your Applications folder. For a PKG, follow the installer steps (you may need to enter your administrator password).
	3.	Bypass Gatekeeper (if needed): If you see an “unidentified developer” warning, right-click the app in Applications and click Open, then confirm. (Our app is code-signed, but this step might be needed on beta versions.)
	4.	Launch: Start DexterDesk from Applications. On first run, macOS will prompt you to grant Accessibility permissions so DexterDesk can manage windows system-wide. Go to System Settings > Security & Privacy > Privacy > Accessibility and enable DexterDesk (you’ll be prompted automatically). This permission is required for window management features ￼.
	5.	Initial Configuration: The app may also request access to your Desktop and Documents folders on first launch—approve this so it can organize files. Once launched, DexterDesk appears as an icon in the menu bar (top right). We recommend setting it to “Launch at Login” via the app preferences for continuous organization.

Linux (Installer .deb or .rpm)

System Requirements: A 64-bit Linux OS (tested on Ubuntu 20.04+/Debian and Fedora 33+), a graphical desktop environment (X11 recommended), and ~150 MB free disk space.
Installation Steps:
	1.	Download Package: Obtain the appropriate package for your distribution:
	•	Debian/Ubuntu-based: dexterdesk_<version>.deb
	•	Fedora/Red Hat-based: dexterdesk-<version>.rpm
	2.	Install Package:
	•	On Debian/Ubuntu: run sudo dpkg -i dexterdesk_<version>.deb (then sudo apt -f install if dependencies need to be fixed).
	•	On Fedora/Red Hat: run sudo rpm -i dexterdesk-<version>.rpm (or use dnf install).
	•	Alternatively, use a GUI package installer by double-clicking the file.
	3.	Resolve Dependencies: The installer will place DexterDesk in /opt/DexterDesk/ (or appropriate location) and add a launcher. Ensure you have standard libraries (Qt/GTK) as prompted; most are bundled or will be resolved by your package manager.
	4.	Launch: Find DexterDesk in your application menu or run dexterdesk from a terminal. On first launch, grant any requested permissions (it may ask for access to your home directories for organizing files).
	5.	Initial Configuration: DexterDesk will appear in your system tray (or as a background service with an icon). We strongly recommend using X11 session for full functionality; on Wayland sessions, some window management features may be limited due to Wayland’s security model (which restricts programmatic window control ￼). If using Wayland, you can still use file organization features fully.

Android (APK / Google Play)

System Requirements: Android 8.0 (Oreo) or above. For AR features, a device compatible with ARCore (most modern Android devices) is required ￼. ~50 MB free storage.
Installation Steps:
	1.	Download App: Install DexterDesk from the Google Play Store (search “DexterDesk”) if available. If the app is not yet on Play Store or you are using a beta, download the latest .apk from the official website or GitHub Releases.
	2.	Enable Unknown Sources (if using APK): In your device Settings, under Security, allow installation from unknown sources (you may grant this permission to your browser or file manager).
	3.	Install APK: Open the downloaded APK on your device and proceed with installation. You may be prompted to confirm the app’s required permissions during installation or on first launch.
	4.	Launch App: Open DexterDesk from your app drawer. The first time you launch, the app will guide you through initial setup, including signing in (optional) and granting necessary permissions:
	•	Storage permission so it can scan and organize files on your device.
	•	Camera permission if you plan to use the AR-enhanced features.
	•	Notification access (optional, for alerts about your desktop status).
	5.	Initial Configuration: Sign in or create a DexterDesk account (this enables cloud sync between your phone and desktop, but you can skip if you want offline use). The Android app will run a brief tutorial on how to use it to view your desktop organization, trigger sorting, or use the AR mode to visualize your desktop in augmented reality.

iOS (App Store / .ipa)

System Requirements: iOS 14.0 or later on iPhone or iPad. AR features require an ARKit-compatible device (A9 chip or newer, which includes most devices iPhone 6s and up). ~50 MB free storage.
Installation Steps:
	1.	Download App: Get DexterDesk from the Apple App Store. (If you are a beta tester with an .ipa file or TestFlight invite, install via TestFlight or your MDM tool as instructed.)
	2.	Install: If using the App Store, simply tap Get to install. If using TestFlight, tap Install in TestFlight after redeeming the invite code. The app will appear on your home screen as DexterDesk.
	3.	Launch App: Open DexterDesk on your iPhone/iPad. On first launch, approve the requested permissions:
	•	Camera for AR (to overlay your desktop in the real world).
	•	Local Network (if the app needs to discover your PC on the same network for certain sync features).
	•	Notifications (if you want alerts about file organization or suggestions).
	4.	Initial Configuration: Sign in with your DexterDesk account or create one. This links your iOS app with your desktop installations via cloud sync. The app will show a short tutorial, then you can access features like viewing organized files, receiving notifications from your desktop, or using the AR viewer to see a holographic projection of your desktop items on a real surface.
	5.	Permissions on iOS: Note that iOS confines apps to a sandbox, so DexterDesk for iOS primarily serves as a companion to your desktop rather than reorganizing your entire device. It will organize files within its allowed directories or cloud storage if linked, and provide AR visualizations and remote control for your desktop setup.

Configuration Options: After installing on any platform, you can customize DexterDesk to your liking:
	•	Account: You may use DexterDesk logged out (data stays local) or log in to enable cloud sync across devices.
	•	Startup Behavior: In Settings, choose if DexterDesk should start automatically with the system (on desktop OSes) or run background refresh on mobile.
	•	Folder Selection: Choose which folders to organize (e.g., Desktop, Downloads, Documents) and which to exclude. By default, your Desktop folder is managed; you can add others.
	•	Automation Rules: Pick or tweak presets (e.g., “Organize by file type”, “Archive after 30 days”). You can adjust these rules in the configuration file or UI (more in Usage Guide).
	•	Permissions: Ensure required permissions are granted (Windows: none extra, macOS: Accessibility and Disk Access, Linux: file access and possibly Accessibility API for some desktop environments, Android/iOS: as above). The app’s Settings section has a “Permissions & Integration” checklist so you can verify everything needed is enabled.

With installation complete and initial setup done, DexterDesk will be up and running. You should see it monitoring your desktop for changes and ready to assist you. Next, we’ll cover the core features and how to use them effectively.

Core Features

DexterDesk comes packed with features to automate organization and enhance your productivity. Below are the core features and what they offer:
	•	Automated Desktop Organization: DexterDesk continuously tidies up your desktop so you don’t have to. It monitors your Desktop folder (and other configured directories) and automatically sorts files into categorized folders or groups. For example, images, documents, and shortcuts can be grouped into their own folders or visual sections. The system uses intelligent rules (and optional AI) to decide where new files belong. This means that if you download a PDF or save a screenshot to your desktop, DexterDesk might move it to “Documents” or “Pictures” respectively (or any custom category you set) within seconds. The AI-driven approach can even create a unique folder system tailored to your content, placing files in the right place without manual input ￼. Your desktop will remain clean and organized, with frequently used files still easily accessible.
	•	Window and File Management: Beyond files, DexterDesk manages your application windows to keep your workspace efficient. It can automatically arrange and tile windows, snap them to edges, or switch layouts when you dock/undock a monitor. For example, you can configure a hotkey to instantly arrange all open windows side-by-side or move a set of apps to a second screen. DexterDesk essentially provides a smart window manager on top of your OS – it remembers your preferred window sizes and positions for certain apps or tasks (e.g., always put your coding editor and browser side by side). It uses each operating system’s native APIs for robust control (on Windows it leverages the AppWindow API for easy window management ￼, and on macOS it uses the Accessibility frameworks to move and resize other apps). On the file side, DexterDesk introduces powerful file management automation: you can set up rules to handle files (not just on the desktop) – for instance, auto-rename files based on metadata, flag duplicates, or move files older than 30 days into an Archive. All these tasks happen quietly in the background, though you can review and undo any changes via the activity log.
	•	Cross-Platform Compatibility: DexterDesk is truly cross-platform, running on Windows, macOS, Linux, Android, and iOS with a unified experience. The app’s design and functionality are consistent across operating systems, so you don’t have to learn different tools on each device. This means you can organize files on your Windows PC and expect the same DexterDesk rules to apply on your Mac or Linux machine. The mobile apps extend this compatibility by letting you access your organized workspace on the go. A consistent cross-platform design ensures a unified look and feel across devices ￼, and saves you time by avoiding context-switching. For instance, you can start organizing on your desktop and then check on things or receive notifications on your phone. DexterDesk syncs settings and preferences through the cloud, so your automation rules, folder structures, and even window layout preferences can travel with you to any device you use.
	•	Smart Automation and AI-Powered Tools: At the heart of DexterDesk is a smart automation engine. It uses a combination of rule-based logic and machine learning to adapt to your workflow. You can create custom automation scripts or let the AI suggest optimizations. For example, DexterDesk might learn your habits – if you always move screenshots into a “Design Assets” folder, it will start doing that for you. The AI can also analyze file contents to some extent (e.g., detect if a document is a resume vs. an invoice and suggest appropriate categorization). All AI processing is done locally for privacy ￼ – DexterDesk does not upload your files to a cloud for analysis; instead, it uses on-device AI models. These include image recognition for grouping images, natural language processing for file names or content, and predictive algorithms to pre-fetch or recommend files you might need. The smart automation extends to other tasks too: DexterDesk can trigger actions when certain conditions are met (like send a notification if a file that needs your attention appears, or automatically close/minimize specific apps at a set time to reduce distractions). You remain in control – AI suggestions appear in a dashboard for you to approve or ignore, so DexterDesk learns with you over time.
	•	AR-Enhanced UI (Augmented Reality): (Beta Feature) DexterDesk pushes the envelope with an experimental augmented reality mode. This optional feature (currently available on the mobile apps and in future AR glasses integrations) lets you visualize and manipulate your desktop in AR. For example, using your smartphone camera, you can view your actual physical desk or room with virtual representations of your files and windows overlaid in 3D. Imagine pointing your phone at your real desk and seeing your sticky notes, files, or application windows “floating” where you left them in virtual space. Augmented Reality has become increasingly accessible on common devices ￼, and DexterDesk is exploring this to create a futuristic productivity experience. In the AR mode, you might use gestures to move files or enlarge a window preview pinned to your wall. The iOS app uses ARKit and the Android app uses ARCore to anchor these virtual objects in your environment ￼. While this feature is still in beta (and mainly a glimpse of the future), it demonstrates DexterDesk’s innovative approach to rethinking the user interface beyond the flat screen. AR-enhanced UI could especially benefit users with multiple screens or those who want to organize information spatially in their room. (If AR is not applicable to your setup, you can ignore this feature — it’s completely optional and turned off by default.)
	•	Logging and Monitoring: DexterDesk includes comprehensive logging and monitoring tools under the hood. Every action the app takes (like moving a file, renaming something, or resizing a window) can be logged. These logs are accessible through the Activity Log in the app. This feature provides transparency so you can see exactly what DexterDesk has done, and it’s invaluable for troubleshooting or undoing changes. For example, if a file was auto-moved and you’re not sure where it went, you can check the log to find it (and one-click restore it to the original location if needed). Monitoring also includes performance stats — DexterDesk tracks its own resource usage and the outcomes of automation tasks. It will alert you if, say, a particular rule is running frequently or taking a long time, and it can suggest optimizations. Advanced users can enable debug logging to get even more detail (useful when developing new features or reporting issues). On the enterprise side, if you use DexterDesk in a workplace setting, these logs could be sent to a central server for IT monitoring (disabled by default). Rest assured, all logging is local unless you opt-in to share for support purposes. The monitoring extends to a real-time dashboard where you can see what DexterDesk is currently doing, and a notification system that informs you of important events (e.g., “50 files archived to Year2024 folder”). In summary, the logging and monitoring features ensure that you have full visibility and control over DexterDesk’s automated actions.

Technical Implementation

Under the hood, DexterDesk is built with a robust technical architecture, combining modern languages, frameworks, and integrations to achieve its cross-platform capabilities and smart features. This section provides an overview of the technologies used, system architecture, security considerations, and how DexterDesk syncs data across devices.

Technologies Used

DexterDesk is developed using a cross-platform tech stack that balances performance with flexibility:
	•	Languages & Frameworks: The core logic of DexterDesk (handling automation rules, file operations, etc.) is written in C++ for high performance and efficiency. The desktop GUI is built with Qt (C++/QML) to achieve a native look and feel on Windows, macOS, and Linux from a single codebase. Qt’s cross-platform nature ensures we can deploy one codebase to multiple desktop OSes easily. For the mobile apps, we use Swift (SwiftUI) for iOS and Kotlin (Jetpack Compose) for Android to create native experiences that integrate tightly with ARKit/ARCore and mobile OS features. (The choice of native languages on mobile was to fully leverage AR and ensure smooth performance on devices.) We also use some Python and scripting for AI components and prototyping automation flows, and those are embedded via a Python interpreter for flexibility in defining rules. In future, we plan to consolidate more of the code using Flutter or .NET MAUI for an even more unified codebase, as these frameworks allow writing one codebase for multiple platforms ￼, but currently we opted for technologies that gave us maximum control on each platform.
	•	AI and Machine Learning: DexterDesk’s AI features utilize lightweight ML models. We integrate TensorFlow Lite for on-device machine learning tasks like image classification (to recognize file types or content) and text analysis. The models are pre-trained and bundled with the app (for example, a model to detect document types from text). All AI inference happens locally. We use Python (with libraries like scikit-learn) for some rule-based learning and have plans to incorporate ONNX models to allow using a variety of ML frameworks. The AI components are optional modules that run in a sandboxed thread—if you disable AI features, those models won’t load. This modular design keeps the system lean if you only want basic rule-based automation.
	•	APIs and Integrations: DexterDesk integrates with various OS-level APIs. On Windows, it uses the Win32 and UWP APIs for file system monitoring and window management (notably the Windows AppWindow API for manipulating app windows ￼ and the Windows shell API for organizing desktop icons). On macOS, it relies on Apple’s FSEvents for file monitoring and the Accessibility (AX) API to control and read window positions (as required for moving other apps’ windows). On Linux, DexterDesk uses inotify (for file events on ext4 file systems) and X11/Xorg libraries (via Xlib/XTst or WM-specific APIs) to move windows; if running under Wayland, it currently has limited window control due to Wayland’s design (we use xdg-desktop-portal where possible). For cloud and networking, DexterDesk provides integration hooks for services like Dropbox, Google Drive, OneDrive, and iCloud – mainly to coordinate with any existing cloud sync you use. For example, if you have iCloud Desktop syncing on Mac, DexterDesk will detect it and work alongside (so it doesn’t constantly reorganize in conflict with iCloud’s expectations). We also have a custom cloud service (DexterDesk Cloud) for syncing settings (see below).
	•	Database & Storage: The app stores its metadata and settings in a small local database. We use SQLite as an embedded database to keep track of file indexes, user preferences, and logs. SQLite is lightweight and cross-platform, making it a good choice for storing DexterDesk data on all devices. For caching AI model results or thumbnails, we use the local file system (in an AppData folder on Windows, ~/.dexterdesk on Linux, and a sandbox container on macOS and mobile). No large external database or server is required for core functionality – everything can run offline and stored locally, with syncing as an optional layer.

Architecture Overview

DexterDesk’s architecture is modular and follows a client-service model with a core engine and multiple interface components. A high-level overview:
	•	Core Engine: This is the brain of DexterDesk, responsible for automation logic, rule evaluation, and event handling. It runs as a background service (on desktop, it’s a background process launched at login; on mobile, as a background thread when the app is open or via background tasks). The core engine listens for file system events (new file, file modified) and OS events (app opened, window moved, system idle, etc.). It then triggers the appropriate automation rules or AI analysis. The engine is decoupled from the UI, which means it can keep organizing files even if the UI is closed (e.g., running in tray).
	•	Platform Adapters: To interact with each OS, DexterDesk uses adapter modules. For instance, the Windows Adapter handles WinAPI calls for window management and uses the Task Scheduler API to ensure the app starts on boot. The macOS Adapter handles AppleScript or native calls for things like telling Finder to refresh the desktop, and manages the permission prompts. The Linux Adapter abstracts differences between desktop environments (GNOME/KDE) and chooses the right method (it might call xdotool or use KWin scripting interface, etc., depending on what’s available). These adapters present a unified interface to the core engine, so the core can call generic functions like moveWindow(x,y) or createFolder("Photos") and the adapter does the OS-specific work. This architecture makes it easy to maintain cross-platform behavior without cluttering the core logic with platform checks.
	•	User Interface: DexterDesk offers both GUI and CLI. The desktop GUI (built with Qt) provides a system tray icon and a main window interface where users can configure settings, see their organized desktop, and manually trigger actions. The GUI is event-driven, updating in real-time as the core engine organizes or moves things. We maintain a responsive design – for example, on Linux it blends with GTK themes, on Mac it uses native menu bar and dark mode, on Windows it uses Fluent design elements – all achieved through Qt’s theming and some native code injections. The mobile UI (SwiftUI/Compose) is designed for touch and incorporates AR view when needed. Both desktop and mobile UIs communicate with the core engine through a local IPC (inter-process communication) or direct function calls when in the same process. On desktop, the GUI and core might run in separate processes for stability (so a GUI crash won’t stop the background service). They communicate via a local socket or shared memory.
	•	File Structure (Repo Layout): If you peek into the project repository, you’ll find a structured layout:
	•	/core/ – Core engine source code (C++ logic, AI integration code, rule engine).
	•	/ui/ – UI code (Qt QML files for desktop, shared UI components).
	•	/platforms/ – Platform-specific code (subfolders for windows/, mac/, linux/, containing adapters and OS-specific utilities).
	•	/mobile/ – Mobile app projects (ios/ and android/ subdirs with Swift/Kotlin code). These share some logic from /core through a bridging layer or compile the core as a library.
	•	/scripts/ – Scripts for building, packaging, and CI (build pipelines, installer scripts, etc.).
	•	/docs/ – Documentation, designs, and configuration examples.
This modular structure keeps concerns separated and makes it easier for contributors to work on one aspect (e.g., improving Linux support) without affecting others.
	•	Cloud Sync Service: DexterDesk Cloud is an optional component. Its architecture consists of a lightweight server (we provide a cloud service hosted on our servers) that the apps can connect to for syncing data. When you log in on multiple devices, this service exchanges your settings and certain metadata. The data synced includes your preference JSON, rules definitions, and a record of the files organized (not the files themselves, just the index or link if you use a cloud drive). The cloud service is built with a RESTful API (with endpoints like /api/sync/settings, /api/push/log) and uses JSON over HTTPS. If you prefer not to use our cloud, you can set up your own or skip it – the app will function fully without internet, with the only difference being that settings won’t auto-sync across devices. Network syncing also uses end-to-end encryption: your data is encrypted on the device before being sent, using your account credentials, so even our cloud server cannot read your file names or content (zero-knowledge style). This ensures privacy while still providing convenience.

Security Considerations

Security and privacy are core to DexterDesk’s design. Given the level of access DexterDesk has (files, windows, possibly cloud), we’ve implemented several measures to keep your data safe:
	•	Local-Only Processing: By default, all file processing and AI analysis happen locally. Your files’ content is never uploaded to any server for organization. (The only data that goes to our cloud service, if you use it, are metadata like file hashes or preferences, which are encrypted.) This means you can even use DexterDesk completely offline. As one community developer demonstrated with a similar tool, local AI file organization can be done with complete privacy ￼, and DexterDesk follows that principle.
	•	Permission Control: DexterDesk requires certain OS permissions to do its job (like disk access or accessibility control). We only request the minimal set needed and guide you through enabling them. You remain in control and can revoke permissions at any time (though features relying on them will pause). For example, on macOS if you disable the Accessibility permission, DexterDesk will detect that and stop trying to move windows (preventing error spam), but it will continue organizing files (which doesn’t need that permission). We also handle these permissions securely: any data read (file content for classification) is processed in-memory and not written elsewhere. We use OS sandboxing where possible – the Windows version runs with standard user privileges (no admin rights needed unless you choose to install for all users), and the macOS version is sandboxed following App Store guidelines (with appropriate entitlements for file access).
	•	Data Encryption: All communication between DexterDesk apps and the cloud sync server is encrypted via HTTPS/TLS. Additionally, as mentioned, we implement an extra layer of encryption for user data sync: a unique key derived from your password is used to encrypt your sync payloads, meaning even if someone intercepted the data, it’s gibberish without your credentials. Locally, the SQLite databases and config files are not encrypted (for performance and because they’re on your machine), but if you have full-disk encryption (FileVault, BitLocker, etc.), those are covered. Optionally, you can enable an “encrypted logs” setting which will encrypt the activity logs at rest with a password (so even someone with access to your PC account would need an extra password to read the log). This might be used in corporate environments with sensitive file names.
	•	Network Safety: If you utilize the mobile-to-desktop connection on a local network (for remote control features), all data is exchanged over an authenticated WebSocket with a secure key. The desktop app will show a pairing code you must enter on mobile to establish trust (similar to how WhatsApp web pairing works). This prevents unauthorized devices from connecting. We also ensure that the mobile apps abide by OS security (for example, iOS prohibits any malicious behaviors anyway via App Store rules).
	•	Security Audits and Updates: DexterDesk’s code is open-source (or source-available) so it can be audited by the community. We periodically review our third-party libraries for vulnerabilities and issue updates. The app uses secure defaults; for instance, it won’t execute any external scripts or code that it hasn’t shipped with (all automation is done via our built-in engine or user-created rules in a safe domain-specific language, not raw shell commands unless you explicitly enable an advanced “exec” rule). This prevents potentially dangerous operations. We also follow the principle of least privilege: DexterDesk doesn’t run as root/admin, and on Linux we do not recommend using sudo for it (the .deb/.rpm install might place some files in root-owned directories, but the runtime is your user).

Network Syncing and Cloud Integration

DexterDesk’s cross-device experience is powered by its syncing and cloud features. Here’s how it works and what integration options are available:
	•	DexterDesk Cloud (Sync): When you create a DexterDesk account (email & password) and log in on your devices, the app will sync your settings through our cloud. This includes your organization rules, preferences, and desktop layout data (like how you arranged windows in a saved layout). The sync is near real-time: if you change a rule on your PC, within seconds your Mac or phone will get that update (provided they’re online). Under the hood, each client maintains a websocket connection to the cloud for instant push, and falls back to polling every few minutes if the connection is lost. All sync events are versioned, so if two devices make changes offline, the cloud will merge them (or flag a conflict for you to resolve). The data payloads are end-to-end encrypted as described, so even the cloud just stores blobs. This means even we as service providers cannot peek at your organizational structure or file names – only your devices (with your login) can decrypt the sync data.
	•	File Sync and Cloud Drives: DexterDesk itself is not a cloud storage service; it doesn’t upload your actual files. However, it plays nicely with existing cloud drives. For example, many users keep their Desktop folder synced with a service like OneDrive or iCloud Drive. DexterDesk will integrate with these by reading their status (we use OneDrive’s API on Windows to detect if a file is online-only or available offline, etc., so as not to accidentally try to move a cloud-only stub). We also expose an option to “Integrate with Cloud Storage” – if enabled and you link an account, DexterDesk can use the APIs of Google Drive, Dropbox, etc., to, say, move files into those services or clean up space. A simple use-case: If your Downloads folder is in Dropbox, DexterDesk can still organize it, and because Dropbox syncs, those changes propagate. Conversely, if you work on multiple PCs without our cloud, you might rely on something like iCloud to sync the actual files in Desktop; in that case, DexterDesk on each PC can still run and organize, essentially complementing the cloud storage. Having multiple layers is fine – we test to ensure there’s no “tug-of-war” between DexterDesk and services like iCloud Desktop sync.
	•	Network Sync (Local): If you prefer not to use any cloud, DexterDesk has a local network sync mode. In this mode, one device can act as a host (say your PC) and others (your phone or laptop) can connect to it when on the same Wi-Fi/LAN. This uses a direct peer-to-peer connection (WebRTC or local WebSocket) to transmit data. The devices find each other via LAN broadcast or IPv6 multicast (or you can enter an IP). Local sync is encrypted as well and does not leave your network. This is useful for a completely self-contained setup or high-security environments where cloud is disallowed. Keep in mind, local sync requires the devices to be on and on the same network simultaneously to exchange data (whereas cloud sync can work asynchronously).
	•	Logging to Cloud (Optional): Advanced users or IT admins can opt to send activity logs to a secure cloud endpoint (could be our cloud or your own server). This might be used for monitoring or backup of the logs. If enabled, logs are batch-uploaded and viewable on a web dashboard. Again, this is off by default; privacy-oriented users can skip creating any account and use DexterDesk purely offline.
	•	Integration APIs: For those who want to build on DexterDesk, we expose some APIs. There’s a REST API (when DexterDesk is running on your machine, you can enable an HTTP API to query status or trigger actions remotely). Also, we plan on providing a plugin system where third-party developers could integrate other services (for example, maybe link Slack to get a message when a certain file arrives). These integration points are documented in the developer guide.

Overall, networking and cloud features of DexterDesk are designed to be secure, optional, and flexible. You can seamlessly sync your organized desktop environment across all your devices, similar to how Dropbox syncs files across multiple devices for convenience ￼, but with full control over your data.

Usage Guide

Now that you have DexterDesk installed and understand its features, let’s go through how to use it day-to-day. DexterDesk is meant to require minimal intervention once configured, but it also provides interfaces for you to customize and manually control the organization when you want to.

Getting Started

When DexterDesk is running (look for the icon in your system tray/menu bar or the app open on mobile), it immediately begins monitoring and organizing according to the default rules. You can interact with DexterDesk through its GUI or via commands:
	•	Desktop App Interface: Click the DexterDesk tray icon (or menu bar icon on Mac) to open the main dashboard. This dashboard shows an overview of your desktop status: how many files were organized today, any suggestions, and quick actions. You’ll see sections for Files, Windows, Notifications, and Settings.
	•	The Files section might show something like “12 files cleaned up from Desktop this week” and list recent file moves.
	•	The Windows section can show current window layout presets or let you activate a different arrangement.
	•	Notifications will list things like “No new suggestions” or “AR mode available on mobile”.
	•	You can always right-click the tray icon for a quick menu (with options like “Organize now”, “Pause Automation”, “Open Settings”, etc.).
	•	Mobile App Interface: On Android/iOS, opening DexterDesk presents a similar dashboard optimized for small screen. You can swipe through tabs for My Files (which shows your desktop’s file structure as synced), My Desktop (which could show a miniature live view of your desktop or a summary of window positions), and AR View (to launch the augmented reality mode). Use the mobile app to quickly find a file from your desktop when you’re away from your computer, or to get notified if, say, a long-running download finished and was filed away.
	•	Command Line Interface (CLI): DexterDesk provides a CLI for advanced users and scripting. On desktop, you can use the dexterdesk command in a terminal/PowerShell. Running dexterdesk --help will show available commands. For example:
	•	dexterdesk organize – Trigger an immediate run of all organization rules (useful if you disabled auto-mode and want to run it manually).
	•	dexterdesk status – Print out what DexterDesk is currently doing or recent actions.
	•	dexterdesk rules list – List all active automation rules and their status.
	•	dexterdesk rules add "Downloads:*.pdf -> Documents/PDFs" – (Example) Add a rule to move all PDFs from Downloads to a PDFs folder.
The CLI is optional but powerful. It can be used in scripts or integrated with other tools. For instance, you could schedule dexterdesk organize to run at specific times via cron/Task Scheduler if you prefer scheduled cleanup instead of real-time.

Efficient Desktop Organization

DexterDesk largely handles organization automatically, but here are ways to use it efficiently and customize its behavior:
	•	Real-time vs Manual: By default, DexterDesk operates in real-time monitoring mode. This means if you drop a file on the desktop or a tracked folder, DexterDesk will usually organize it within seconds (or minutes, depending on your settings). If you find this too immediate, you can switch it to Manual Mode or Scheduled Mode in Settings. Manual Mode means DexterDesk will only organize when you click “Organize now” or run the CLI command, whereas Scheduled could be, say, every hour or at 3am daily. Choose what fits your workflow. Some users like real-time for continuous cleanliness; others prefer end-of-day cleanups.
	•	Custom Rules: DexterDesk comes with a set of predefined rules (which you can enable/disable) such as:
	•	“Move images (PNG, JPG) from Desktop to Pictures after 1 day”
	•	“Delete temporary files (.tmp) in Downloads after 7 days”
	•	“Tag new documents with ‘New’ tag for 24 hours”
You can create your own rules in the Rules Editor (accessible via the Settings or a dedicated tab). The rules can be simple matching patterns or more complex conditions. For example, you can write a rule: If file type is .log and file size > 10MB then move to Archives/Logs and compress it. The rule editor provides a user-friendly form for most cases, and an advanced script mode for complex logic. Under the hood, advanced rules use a Python-like syntax with safe execution. Once you add or edit a rule, the changes apply immediately and sync to your other devices if logged in.
	•	Undo and History: If DexterDesk moves or renames something you didn’t want it to, you can easily undo. In the Activity Log GUI, each entry has an “Undo” button next to it. Click that and DexterDesk will attempt to reverse the action (move the file back, etc.). The log persists actions for at least 30 days by default (configurable). You can also use dexterdesk undo <action_id> in CLI for the same effect. This allows you to try aggressive organization strategies without fear — you can always revert changes.
	•	Temporary Pause: When you’re doing something where you don’t want DexterDesk to interfere (say, presenting or working with files that you’ll clean manually), you can pause automation. Right-click the tray icon and select Pause DexterDesk (or use dexterdesk pause). This will stop any new automated actions until you resume. While paused, DexterDesk still logs events but won’t move files or resize windows.
	•	Desktop Stacks (Visual Grouping): DexterDesk introduces a concept called Stacks for those who prefer some organization on the desktop itself. Similar to how macOS has Stacks by kind, DexterDesk can group icons on your desktop into labeled stacks (e.g., “Images”, “Docs”, “Shortcuts”) while still leaving them visible on the desktop. This is an alternative to physically moving files into subfolders. You can toggle this mode if you like seeing everything at a glance but still want it grouped. In the Settings under Desktop Appearance, enable Visual Stacks. DexterDesk will then arrange your desktop icons into columns or grids by category with headings. (If you prefer a totally empty desktop with no icons, simply enable “Hide all desktop icons” and rely on the DexterDesk GUI or Finder/Explorer to access files.)

Window Management Usage

DexterDesk’s window management features are like having a personal window butler:
	•	Window Layout Presets: In the GUI, go to the Windows or Layouts section. Here you will find preset layouts (e.g., 2-column split, 3-app grid, focus mode with one window centered, etc.). Click any preset, and DexterDesk will instantly rearrange your open application windows to match that layout. You can create custom layouts too: arrange your windows as you like, then click “Save Layout” and give it a name (for example, “Video Editing” or “Writing”). DexterDesk will remember the app positions and sizes relative to your screen. Later, you can restore that layout with one click – it will even reopen apps if they are part of the layout and not currently running (this uses a setting where you allow DexterDesk to launch apps).
	•	Hotkeys & Gestures: DexterDesk sets up some convenient shortcuts by default (all customizable):
	•	Press Ctrl+Alt+O (Command+Option+O on Mac) to trigger an instant “Organize Windows” – this applies your last used layout or a default tiling of all windows.
	•	Press Ctrl+Alt+Arrow Keys to snap the focused window to halves or quadrants of the screen (similar to built-in Windows snapping, but more flexible).
	•	On macOS, DexterDesk adds shortcuts that macOS lacks by default, like Ctrl+Alt+Up to maximize a window without going fullscreen, etc.
	•	You can configure hot-corners or trackpad gestures (on supported laptops) to do things like “swipe three fingers up to show a quick bird’s-eye view of all windows with their titles,” courtesy of DexterDesk’s integration.
All these are adjustable in the Shortcuts settings panel. If a default shortcut conflicts with something you use, you can remap or disable it.
	•	Virtual Desktops & Workspaces: DexterDesk can tie into virtual desktop (workspace) features of your OS. For instance, on Windows 10/11 it can create and name Virtual Desktops for you (like one for Work, one for Gaming) and move windows between them based on rules (maybe your communication apps always move to Desktop 2). On Linux, it can interface with the multiple workspace feature of your environment. And on macOS, it uses Mission Control’s spaces. This way, automation can extend to separating contexts. For example, you could set a schedule: during work hours, open certain apps and arrange on Space 1 (work stuff), and move personal or distracting apps to Space 2 or minimize them.
	•	Focus Mode: A notable feature is Focus Mode. This is for those times you need to concentrate. You can activate Focus Mode from the tray or with a hotkey. When on, DexterDesk will minimize or hide all windows except the active one, mute notifications, and even darken background windows (on some OS it puts a semi-transparent overlay on everything except the active window). It essentially simulates a single-task environment. When you exit Focus Mode, all your windows come back to where they were. This feature is great for temporarily clearing the screen. You can customize what it does (maybe pause file organization too so it doesn’t pop up anything, etc., while focusing).

Customization & Settings

DexterDesk is highly configurable. Open the Settings panel (from the GUI dashboard or right-click menu) to explore these options:
	•	General Settings: Here you can enable/disable major components (e.g., turn off Window Management entirely if you only want file organization). You can also set DexterDesk’s theme (light, dark, or OS default).
	•	Automation Rules: As discussed, this tab allows editing and adding rules. You can also import/export rule sets here. For example, you might create a set of rules tailored for photo management and export it to share with a friend or apply on another machine.
	•	AI Settings: If you want more control over the AI features, this is where. You can toggle specific AI modules like “Content-based file tagging” or “AI suggestions for new folders.” If you’re privacy-conscious, you can leave them all off and rely purely on manual rules. If on, you can adjust how aggressive the AI is (e.g., only suggest actions vs. automatically do low-risk actions). The first time AI moves a file on its own, it will notify you and wait for confirmation (learning from your response).
	•	Notifications: Customize when DexterDesk notifies you. For instance, you might want a summary each day of what was organized, but you might not want a pop-up for every single file moved. You can also mute all notifications and just rely on logs. On mobile, you can pick which notifications to receive (e.g., maybe you want an alert if a certain important file appears or if your disk is getting full in one folder after cleanup).
	•	Integration Settings: If you link cloud accounts (Dropbox, etc.), you’ll see them here and can manage which services are active. You can also generate an API token for the DexterDesk API if you plan to use the CLI or scripts remotely.
	•	Advanced (Power User) Settings: This section, typically hidden by default, includes toggles and configuration for things like:
	•	Changing the location of the DexterDesk database or logs.
	•	Adjusting performance parameters (e.g., how many files per second it can process, useful if running on a low-power NAS or something).
	•	Setting ignore patterns globally (maybe you want DexterDesk to never touch .git folders or certain file types).
	•	Enabling debug mode or verbose logging.
	•	Scripting: There’s a console where you can run ad-hoc commands to interact with the engine, primarily for developers or for troubleshooting.

All settings changes take effect immediately and, if you’re logged in, sync to your other devices. So if you disable a certain rule on your laptop, it will also disable on your desktop at home via sync.

Augmented Reality Usage (Experimental)

If you are trying out the AR-enhanced UI on mobile, here’s a quick guide:
	•	Ensure you granted camera permission. Prepare a flat surface (like your desk or a wall) in a well-lit area.
	•	In the mobile app, go to AR View. The camera will open, and you’ll see instructions to slowly move your device to scan the area. The app is detecting surfaces to place virtual objects.
	•	After a moment, you’ll see your desktop’s outline or some icons floating. You can tap on a floating folder or window to bring it closer or see details. For instance, tapping a virtual window might show a live preview of that app from your PC (this works if your PC is on and connected via network).
	•	You can “pin” files to physical locations. Say you have a project folder you want quick access to – point your phone at your bookshelf and drop a virtual folder there. Later, when you scan that area, you’ll see that folder accessible. (This is somewhat experimental and works via the cloud sync remembering the AR placement.)
	•	Use gestures: one finger tap selects an item, two-finger pinch can resize a virtual object (make a file icon bigger or smaller), and you can drag items around in AR to rearrange. If you have an AR headset (in future), DexterDesk aims to support that as well for an always-on AR desktop experience.

Again, AR is currently just a tech preview feature. It’s fun to experiment with, but it’s not critical for productivity. Feel free to skip it if it doesn’t interest you. The traditional GUI and automation work regardless of AR.

Tips for Productivity
	•	Regular Review: Let DexterDesk handle the grunt work, but do spend a minute each week to review its suggestions. The AI might recommend you create a new folder for a set of files you frequently group together, or suggest deleting duplicates. These appear in the Notifications panel as gentle prompts. Acting on them (or dismissing them) helps train the system and keeps things tailored to you.
	•	Use Tags: DexterDesk supports tagging files (works on Windows through NTFS Alternate Data Streams, on Mac via Finder tags, and internally on Linux). You can tag files with keywords (like “urgent”, “todo”, “personal”). Tags are visible in the file manager and can be used in rules. For example, tag a file “keep” and a rule can be set to never move or delete files with that tag.
	•	Leverage Mobile for Reminders: If you enable push notifications to your phone, DexterDesk can serve as a reminder system. E.g., if you leave work and an important file was added to your desktop by a colleague, you get a notification on your phone so you won’t miss it. Or set it so that if there are unfiled items on your desktop for more than a day, it pings you.
	•	Learn Shortcuts: Investing a little time to learn or customize keyboard shortcuts for common actions (like summoning the Dex dashboard, or triggering a layout) can significantly speed up your workflow. Many users set up a custom hotkey to bring up a quick-switcher (DexterDesk has a Quick Open feature – sort of like macOS Spotlight – where pressing a hotkey lets you fuzzy-search for a file or app, including those recently organized).
	•	Community Rules: Check out the DexterDesk community (Discord or forums) where users share their custom rules and tweaks. You might discover a clever automation script someone made (for example, one that interfaces with your email or does a backup of certain files when a USB drive is plugged in). DexterDesk can import these community scripts to extend its functionality.

With these guidelines, you should be well on your way to making the most of DexterDesk. The key is that the tool is flexible: you can use it in a hands-off automatic way, or as an actively managed assistant, whichever suits your style.

Testing and Debugging

Quality assurance is crucial for a tool like DexterDesk that interacts with many aspects of your system. We have implemented a thorough testing strategy, and we provide guidance for troubleshooting common issues.

QA Process and Test Cases

During development, DexterDesk goes through continuous integration testing on multiple platforms. Every new code contribution triggers automated tests on Windows, macOS, and Linux build agents (and we run separate suites for Android and iOS as well). Using cloud CI services allows us to perform release builds and tests across OSes easily ￼ to ensure consistency.

Some key test scenarios include:
	•	File Operations Testing: We simulate directories with thousands of files of various types to ensure the organization engine handles them correctly (no data loss, correct categorization). Tests verify that rules execute as expected (e.g., a test drops 100 mixed files into a folder and checks that after running the organizer, they ended up in the correct subfolders).
	•	Window Management Testing: Automated UI tests (using tools like Appium and Selenium for desktop or OS-specific UI automation frameworks) move windows and verify DexterDesk positions them in the intended layout. We test multi-monitor setups virtually to ensure the window arranger accounts for different screen resolutions and arrangements.
	•	Cross-Platform Consistency: We run a set of cross-platform tests where the same user scenario is executed on each OS. For example: “User creates a rule to move .txt files to Documents, then creates a txt file on desktop.” We confirm that on Windows, Mac, and Linux the outcome is the same. Similarly, we test that a layout saved on Windows can be applied on Mac (taking into account OS differences in app naming).
	•	Performance and Stress: Long-duration tests keep DexterDesk running for days, adding and removing files, opening and closing windows, to catch any memory leaks or performance degradation. We also test on lower-end hardware (older PCs, a low-end Android device) to ensure the app remains responsive under load.
	•	Mobile-Desktop Sync: Integration tests cover scenarios of syncing: e.g., change a setting on mobile, verify it reflects on desktop. Or go offline on one device, make changes, then reconnect and see that merges happen correctly.

All critical bugs found in testing are tracked and must be resolved before a release. For transparency, we also maintain a list of Known Issues in the documentation, so users know if, for instance, “Linux Wayland: can’t move other app windows (limitation)” or “Android 8: notification delay issue”.

Troubleshooting Common Issues

Despite careful testing, you might encounter issues. Here are solutions to common problems:
	•	Files not organizing as expected: If you notice files that should be moved are staying put, first check the Activity Log to see if there were any errors. A common cause is missing permissions. On Windows, ensure DexterDesk has access to the folder (if it’s on a network drive or a system-protected folder, it might not). On macOS, if it’s your first time adding a new folder (say, Downloads) to be managed, you might need to grant DexterDesk “Full Disk Access” in System Preferences. After adjusting permissions, click “Organize now” again. Also, verify the rule is enabled and order of rules – if you have conflicting rules, one might override another.
	•	Window management features not working (Windows/Linux): On Windows, if windows aren’t snapping or moving, ensure DexterDesk is running with the proper privileges. Normally, user-level is fine, but if the windows belong to apps running as Administrator (e.g., an admin-level app cannot be moved by a user-level process), you might need to run DexterDesk as admin as well. We generally advise against that for security, but it’s a Windows limitation with UAC. On Linux, if using Wayland, note that automatic window positioning is largely disabled by the OS design ￼. You may need to log in with an “X11 session” to allow these features until we have a Wayland-specific solution. Also, check that your desktop environment’s compositor or window manager isn’t preventing external control (KDE and GNOME have settings for allowing/disallowing programmatic window moves).
	•	Mac Accessibility permission not enabled: On Mac, if DexterDesk can’t move or resize windows at all, it likely doesn’t have Accessibility permissions. Go to System Preferences > Security & Privacy > Privacy > Accessibility and make sure the checkbox for DexterDesk is checked. If it’s already checked but not working, try toggling it off and on, then restart DexterDesk. (This prompts macOS to refresh the permission.) As noted, without this, any app cannot implement window management due to macOS security ￼.
	•	High CPU or memory usage: DexterDesk is designed to be lightweight, but heavy file operations or a misbehaving rule (like a rule that triggers in a loop) could cause high resource usage. If you see sustained high CPU from DexterDesk, open the Diagnostics panel (in Advanced Settings). This will show which component is busy. Often it’s an AI indexing process (perhaps scanning a very large file). You can temporarily disable AI features to see if it drops. We also provide a profiling log (enable “Performance logging”) which after a few minutes can pinpoint the last actions. In some cases, a corrupted configuration file could cause repeated retries – resetting the config to default can resolve that (there’s a button for that in Advanced Settings, and you can choose to keep your rules while resetting other preferences).
	•	Mobile app not connecting to desktop: If your phone app isn’t syncing with your desktop, ensure that:
	1.	You’re logged into the same DexterDesk account on both.
	2.	The desktop is online (if PC is off or DexterDesk not running, obviously sync stops).
	3.	If on the same network and using local mode, ensure both devices are on the same Wi-Fi. You may also need to disable any firewall blocking on the PC for the DexterDesk service. The app uses a specific port (e.g., 7676 TCP) for local discovery – make sure that’s allowed.
	4.	If using cloud sync, check the status in Settings > Account. If it says “Unable to reach server”, maybe our server is temporarily down or being blocked by your network. It rarely happens, but you can always sync later.
	•	AR mode issues: AR is still new, so if you encounter a blank camera feed or jittery AR objects: make sure the device supports AR and that you moved the device around to let it calibrate. Good lighting and a textured surface help AR tracking. If the AR objects appear but float away or are inaccurate, it could be due to tracking loss – try resetting by leaving AR mode and re-entering, or tapping the screen to prompt a focus. On some older devices, AR mode might not initialize at all – in that case, the feature may not be supported on that hardware.
	•	Updates not applying or installation issues: On Windows, sometimes an update might fail if the app was not fully closed. If you used the in-app updater and something went wrong (e.g., app didn’t restart properly), you can always download the latest installer and run it manually; it will upgrade your installation. On macOS, replace the app in Applications with the new one. Your settings will be preserved in both cases. If the Linux package manager shows dependency issues on upgrade, ensure you have the required libraries (we list them in the docs) or consider using our AppImage/Snap (if we provide one) for easier updating.

If your issue isn’t listed or the suggested fix doesn’t work, check our GitHub Issues page – someone may have reported a similar issue, and we or the community might have a workaround. You can also enable debug mode (dexterdesk --debug) and watch the console or log file for clues, then share that information when seeking help.

Getting Support for Issues
	•	GitHub Issues: The best place to report a bug is on our GitHub repository’s Issues section. Please include details like your OS, DexterDesk version, and steps to reproduce the problem. Attaching the relevant log snippet (found in ~/.dexterdesk/log.txt on Linux/Mac, or %AppData%\\DexterDesk\\log.txt on Windows) is very helpful.
	•	Community Help: Join our Discord server or community forum where fellow users and the dev team hang out. Often, someone might have had the same issue and can assist quickly.
	•	Logging an Issue (Tool): Within the app, under Help, there’s an option “Report a Problem”. This will compile a small report (including system info and logs, after asking your permission) and can send it to us or save it for you to attach in an issue. This makes it easier to debug complex cases.

We aim to address reported issues promptly. Regular updates are released (we try for bi-weekly minor updates and quarterly major updates), frequently including bug fixes and improvements based on user feedback.

Contribution and Development

DexterDesk is an open-source project (hosted on GitHub: github.com/YourRepo/DexterDesk) and we welcome contributions from developers, designers, testers, and enthusiasts! This section outlines how to set up a development environment, the repository structure, the process for contributing code or documentation, and details about our CI/CD pipeline.

Project Structure & Build Process

As mentioned in Technical Implementation, the repository is organized into directories by component. Depending on what you want to work on, the build process will differ:
	•	Desktop (Qt C++ code): The desktop application uses CMake for build configuration. To get started, you should have a C++ development environment set up (e.g., Visual Studio or MinGW on Windows, Xcode command-line tools on Mac, GCC/Clang on Linux). Also install Qt 6.x (the open-source version is fine) or use vcpkg to fetch Qt. Then:
	1.	Clone the repository: git clone https://github.com/YourRepo/DexterDesk.git.
	2.	Install any dependencies: For example, on Ubuntu, run sudo apt-get install qtbase5-dev qtdeclarative5-dev libsqlite3-dev (if not using the bundled ones). We also include a requirements.txt for Python parts (for AI scripts), so run pip install -r requirements.txt in a Python 3.x environment.
	3.	Create a build directory: mkdir build && cd build.
	4.	Run CMake: cmake .. (add -G "Visual Studio 17" on Windows to generate a VS solution, or appropriate generator). CMake will detect your OS and configure relevant sub-projects (it can optionally include mobile builds if you have those SDKs, but usually we handle mobile separately).
	5.	Compile: cmake --build . (or open the generated solution in Visual Studio/Xcode and build). This will produce the DexterDesk executable and necessary libraries.
	6.	You can find the output in, e.g., build/bin/Debug/DexterDesk.exe (Windows) or build/DexterDesk.app (macOS) or build/bin/DexterDesk (Linux).
	7.	Run the app from the build directory to test your changes.
	•	Mobile (iOS & Android): The mobile apps are in mobile/ios (an Xcode project) and mobile/android (an Android Studio project). They share some code with the core via a library or through source includes:
	•	For iOS: Open mobile/ios/DexterDesk.xcodeproj in Xcode. Ensure you have CocoaPods installed, as we use it to bring in some pods (like Firebase for push notifications, if applicable). Run pod install in the ios directory if needed. Then build and run on a simulator or device.
	•	For Android: Open mobile/android in Android Studio (Flamingo or later). You’ll need Android SDK 30+. Gradle should sync and download dependencies. Then build and run on an emulator or device.
	•	We try to keep mobile in parity with the desktop core logic by periodically updating a shared config file and some logic classes (in core/ we have code that can be compiled to a static library that the mobile apps link against for consistency in rules processing).
	•	Web (Future possibility): We have an experimental web dashboard for DexterDesk (for remote access). It’s in web/ and built with React. This isn’t a primary target yet, but if you’re interested, you can do npm install and npm start there to run a development server.
	•	Testing: We use Google Test for C++ unit tests. Tests are located in tests/ directory. To build the tests, pass -DBUILD_TESTS=ON to CMake and then run the test binary. For Python scripts, we use pytest (run pytest in the repository root to run those). And for integration tests, we have some scripts under ci/ that simulate user flows. If you contribute new features, please try to add or update tests accordingly.

Contributing Guidelines

We encourage contributions! To contribute:
	1.	Fork the repository on GitHub and then clone your fork locally.
	2.	Create a branch for your feature/bugfix: e.g., git checkout -b feature/improve-ai-tagging.
	3.	Make changes in the code, add new files under the appropriate folder. Please follow the existing code style:
	•	C++: We follow a style roughly based on LLVM conventions (braces on same line, 4-space indent, descriptive variable names). There is a .clang-format file in the repo – feel free to use it to format your code.
	•	Python: PEP8 style.
	•	Comments: Use Doxygen-style comments for functions and classes in core code, as we generate reference docs from those.
	4.	Test your changes thoroughly. Run unit tests (ctest after building, or via Visual Studio Test Explorer, etc.). If it’s a UI change, test on all platforms if possible or at least do not break build on others.
	5.	Commit with a clear message: e.g., “Add ability to tag files as Favorites” and push to your fork.
	6.	Open a Pull Request on the main repo. Fill out the PR template, explaining what changes you’ve made and why. If it fixes an open issue, reference that issue number.
	7.	A maintainer will review your PR. We might ask for adjustments or run additional tests. Once approved, your PR will be merged into the develop (or main) branch.

We have a Contributor Guide (CONTRIBUTING.md in the repo) with more details, including how to write good commit messages and code of conduct. Please ensure you read and adhere to the Code of Conduct as well (located in CODE_OF_CONDUCT.md), which basically asks everyone to be respectful and collaborative.

Repository Branches and CI/CD

Our Git repository typically has the following branches:
	•	main – the stable branch containing releases or hotfixes. We only push to main when we prepare a release (through PRs).
	•	develop – the active development branch where new features and fixes accumulate. This is the default branch for most contributions.
	•	We may have feature branches or use PRs for any changes to develop.

When you submit a PR, our Continuous Integration pipeline will run automatically. We use GitHub Actions for CI, configured in .github/workflows/. The CI pipeline will:
	•	Build the project on Windows, macOS, and Linux (we have matrix builds) to ensure cross-platform compatibility.
	•	Run unit tests and integration tests on those platforms.
	•	Lint the code (we use clang-tidy for C++, flake8 for Python, etc.).
	•	If all checks pass and the PR is approved, we merge it.

For releases, we tag a commit on main (like v1.0.0). GitHub Actions then kicks off a CD pipeline:
	•	It will create release build artifacts for each platform: a signed Windows installer .exe, a signed macOS app (DMG or PKG), Linux packages (.deb, .rpm, and an AppImage), and the mobile app packages (APK for Android, an XCArchive or .ipa for iOS).
	•	These artifacts are automatically uploaded to the GitHub Releases page for that tag. The workflow is configured to do this all in one go, which saves us time and ensures all builds are from the same source. Using a cloud CI/CD to produce multi-OS release builds is an efficient way to deliver our app ￼.
	•	We also run a last set of sanity tests on those built artifacts (some smoke tests like launching the app, checking the version number, etc., via script).

The CI also helps contributors: if your PR fails the build or tests on a platform you didn’t test (say, you’re on Windows but it fails on Linux), you’ll see that in the PR status. We encourage contributors to try to fix those issues; maintainers can assist if needed.

Where to Contribute

You don’t have to be a coder to contribute! Here are various ways:
	•	Code: Implement a new feature on the roadmap or fix a bug. Check issues labeled “good first issue” or “help wanted”.
	•	Documentation: Improve our README or the docs in /docs. Clear documentation is just as important as code. If you find something confusing in the instructions, help us clarify it.
	•	Design/UX: If you have ideas for a better UI or new icons/graphics, we welcome design contributions. Perhaps you can create a better icon for the app or suggest a new layout for the dashboard.
	•	Testing: Download development builds (we sometimes post nightly builds) and test new features. Report issues or confirm that issues are fixed.
	•	Community Support: Help answer questions from other users in Discord or GitHub Discussions. Share your workflows or rule sets.

We value every contribution. All contributors are credited in our release notes and on the project site. By participating, you agree that your contributions will be licensed under the same license as the project (so that they can be distributed with DexterDesk).

Finally, if you’re unsure about anything, feel free to open a discussion or issue to ask. We’re a friendly community and happy to help you get started contributing to DexterDesk.

Future Roadmap

DexterDesk is under active development, and we have big plans for the future! Here are some of the planned features and updates we envision:
	•	Enhanced AI Capabilities: We plan to integrate more powerful AI, potentially leveraging large language models for even smarter assistance. For example, you might be able to ask DexterDesk (via a chat interface) to “organize project X files by date and highlight the latest version” and it would understand and execute that. We are exploring integrating with local LLMs or an online optional service for natural language commands and smarter context understanding.
	•	Plugin System: Introduce a plugin/extension architecture. This will allow third-party developers to add new functionality to DexterDesk easily. For instance, a developer could create a plugin to integrate DexterDesk with a specific tool (like Trello or Slack) – imagine automatically moving a file to a certain folder when a Trello card is moved to Done, etc. A plugin system could use a simple API or scripting hooks that trigger on certain events.
	•	Augmented Reality Improvements: Expand the AR features once the technology matures. This includes better stability in AR view and support for AR glasses (like Apple Vision Pro, Meta Quest Pro in passthrough mode, etc.). We want to be ready for a future where using AR for productivity is more common. The AR interface could gain the ability to actually control the desktop (not just view). For example, picking up and moving an AR window could rearrange windows on the actual PC in real time. Also, multi-user AR collaboration is a thought—two people in the same room with AR could share a “workspace” of DexterDesk items.
	•	Voice Control Integration: Adding voice commands (perhaps integrated with the OS’s voice assistant or a custom one). You could say “Dexter, clean up my desktop” and it will execute the command. Or “Open the report from yesterday” and DexterDesk finds and opens the file for you. Voice interactions combined with the AI could make for a very powerful hands-free experience.
	•	Better Linux Wayland Support: We aim to fully support Wayland once the necessary protocols (like for window management) become available. This might involve contributing to upstream projects or using evolving standards (like xdg-desktop-portal improvements). A goal is that DexterDesk will work seamlessly on modern Linux distributions without needing X11, within the next few release cycles.
	•	Mobile App Expansion: Right now, the mobile apps are companion apps. In the future, we might expand their functionality so they can serve as standalone organizers for the device (organizing files in the phone’s storage, managing apps on the phone etc., basically bringing some of the desktop features to mobile local storage). Additionally, features like using your phone as a trackpad to manipulate your desktop via DexterDesk, or scanning documents with phone camera and having them auto-file to your desktop, are on the table.
	•	Cloud Backup of Settings and Profiles: While we sync settings, we plan to offer an optional cloud backup of your entire DexterDesk profile (including logs, rules, etc.), so when you switch machines you can restore everything. Possibly even versioned backups so you can revert to a previous setup if needed.
	•	UI/UX Refinements: We continuously refine the interface based on user feedback. Upcoming improvements might include a more intuitive rule editor (with templates for common tasks), a wizard for new users to set up in less than 2 minutes, and more visualization of what DexterDesk is doing (like a live animation or graph of your storage being cleaned up over time).
	•	Performance Optimizations: As more features are added, we will work on keeping the app lightweight. Plans include moving some processing to background threads or even dedicated worker processes (so a heavy file operation doesn’t ever freeze the UI), optimizing database access for large numbers of files, and reducing memory footprint on smaller devices.
	•	Localization and Internationalization: We want to make DexterDesk accessible to non-English speakers. We will be setting up a translation framework so the community can help translate the UI and documentation into multiple languages. This includes handling different file system conventions and date formats, etc., for rules.
	•	Enterprise Features: Considering interest from organizations, we might add enterprise-oriented features: for example, a centralized dashboard for IT admins to deploy DexterDesk configurations to multiple PCs, or a “team mode” where certain organization rules are shared among a team for consistency. Also, integration with directory services (like Active Directory) to manage permissions/policies for the app.

The above roadmap is subject to change based on user feedback and contributions. We prioritize features that our user community asks for, so please let us know your ideas (you can use GitHub Discussions or our feedback form on the website). The future of DexterDesk is exciting, with possibilities that blend automation, AI, and even AR into the daily computing experience.

Contact and Community Support

We believe in building a strong community around DexterDesk. Whether you need help, want to provide feedback, or contribute, here are the channels available:
	•	GitHub: Our GitHub repository (@YourRepo/DexterDesk) is the central hub for development. Use the Issues section to report bugs or request features, and Pull Requests for contributing code. We also have GitHub Discussions enabled for general topics, Q&A, and idea brainstorming.
	•	Discord Community: Join our Discord server to chat with developers and other DexterDesk users in real time. We have channels for support (#help), tips and tricks (#share-your-setup), development (#dev-chat), and announcements for new releases. It’s a friendly place to ask quick questions or discuss usage scenarios. (Invite link: discord.gg/abc123 for example.)
	•	Official Website: Visit dexterdesk.com for official news, blog posts, and a knowledge base. The website hosts detailed documentation, FAQs, and tutorials (for example, a step-by-step guide to setting up complex rules, or a spotlight on a user’s organized workspace). You can also find links to download releases from here.
	•	Email Support: If you prefer email or have specific inquiries (including any security concerns or private issues), you can reach the team at support@dexterdesk.com. We try to respond within 1-2 business days.
	•	Social Media: Follow us on Twitter (X) at @DexterDeskApp for quick updates, tips, and announcements. We also occasionally post videos on YouTube demonstrating new features and how-to guides. If you create content about DexterDesk, please tag us—we love to see user reviews and setups!
	•	Community Forums: Aside from Discord and GitHub, we maintain a forum on our website for those who prefer a classic forum format. This is great for longer-form discussions or if you want to search through archives of past solutions.
	•	Newsletter: You can subscribe to the DexterDesk monthly newsletter via the website. We’ll share development updates, highlight community contributions, and provide productivity tips.

Remember, DexterDesk is built by and for its users. We encourage you to engage with the community, share feedback, and even showcase how you use DexterDesk. Your input directly influences future improvements.

If you encounter any issues or have questions, don’t hesitate to use the above channels. There are many users and contributors who can help out. We aim to foster an inclusive and helpful community environment.

License Information

DexterDesk is an open-source project, released under the MIT License. This means you are free to use, modify, and distribute the software, provided you include the original license text and copyright notice. The full license text is available in the LICENSE file in the repository.

MIT License Summary: You can do what you want with the code as long as you provide attribution back to the authors. The software is provided “as is”, without warranty of any kind. In non-legal terms, we hope DexterDesk is useful to you, but if something goes wrong, the contributors and maintainers are not liable for damages.

We also want to acknowledge that DexterDesk uses some third-party libraries and tools, which may be under their own licenses (for example, Qt is LGPL/commercial, some Python packages under BSD/MIT, etc.). We include copies of those licenses in our distribution where required (see the THIRD_PARTY_LICENSES.md file for a list of attributions).

Disclaimer: While we strive to make DexterDesk safe and reliable, managing files and windows inherently comes with some risk. By using the software, you agree that the authors are not responsible for any loss of data or other issues that may arise. Always keep backups of important data. We have built-in safeguards and thoroughly test, but it’s good practice to be cautious with any tool that can move or delete files.

In summary, DexterDesk is free and open for personal or commercial use under MIT. We encourage you to read the license if you’re interested, and enjoy the benefits of the software without heavy restrictions.
